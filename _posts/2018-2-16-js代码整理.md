---
layout: post
title: js代码储备
subtitle: HashTable 继承
date: 2018-2-16
author: jacob
header-img: img/post_bg_02.jpg
catalog: true
tags: 
    - js  
    - 继承
    - 
---
## js

### 模拟一个HashTable类，包含有add、remove、contains、length方法;

```
 function HashTable(){
     this.arr = [];
 }
 HashTable.prototype.add = function(data){
     this.arr.push(data);
 }
 HashTable.prototype.remove = function(i){
     if(this.arr[i]){
         <!-- delete this.arr[index]; --> length不变 empty占位
         this.arr.splice(i,1);//返回删除的值
     }
 }
 HashTable.prototype.contains = function(data){
     if(this.arr.indexOf(data)!==-1){
         return true;
     }else{
         return false;
     }
 }
 HashTable.prototype.length = function(){
     return this.arr.length;
 }
```
### js继承

父类

```
function Animal(name) {
    this.name = name || 'Animal';
    this.colors= ['red','green']
    this.sleep = function () {
        console.log(this.name + "sleep")
    };
}
Animal.prototype.eat = function (food) {
    console.log(this.name + 'eat' + food);
}
```

1. 原型链继承
核心： 将父类的实例作为子类的原型

```
  function Cat(){
  };
  Cat.prototype = new Animal('cat');
  <!-- Cat.prototype.name = 'cat' -->
  console.log(Cat.name)//cat
  console.log(Cat.sleep)//cat sleep
  console.log(Cat.eat('fish'))//cat eat fish
   
   var s1 = new Cat();
   s1.colors.push('black'); //[ 'red', 'green', 'black' ]
   var s2 = new Cat();
   console.log(s2.colors) ;//[ 'red', 'green', 'black' ]

```

非常纯粹的继承关系，实例是子类的实例，也是父类的实例
父类新增原型方法/原型属性，子类都能访问到
简单，易于实现
缺点：

要想为子类新增属性和方法，必须要在new Animal()这样的语句之后执行，不能放到构造器中
可以在Cat构造函数中，为Cat实例增加实例属性。如果要新增原型属性和方法，则必须放在new Animal()这样的语句之后执行。
无法实现多继承
原型链上中的原型对象它俩是共用的。
创建子类实例时，无法向父类构造函数传参

2. 构造函数继承

```
    function Cat(name){
        Animal.call(this);
        this.name=name||'Tom'
    };
    Cat.prototype.sex = '男';

    var cat = new Cat();
    console.log(cat.name)//Tom
    console.log(cat.sleep)//Tom sleep
    console.log(cat.eat('banana'))//Tom eat banana

    console.log(cat.sex)//undefined   Child无法继承Parent的原型对象，并没有真正的实现继承（部分继承）
```

解决了1中，子类实例共享父类引用属性的问题
创建子类实例时，可以向父类传递参数
可以实现多继承（call多个父类对象）
缺点：

实例并不是父类的实例，只是子类的实例
只能继承父类的实例属性和方法，不能继承原型属性/方法
无法实现函数复用，每个子类都有父类实例函数的副本，影响性能

3. 实例继承

```
function Cat(name){
    var instance = new Animal();
    instance.name = name || 'Tom';
    return instance;
  }
  
  // Test Code
  var cat = new Cat();
  console.log(cat.name);
  console.log(cat.sleep());
  console.log(cat instanceof Animal); // true
  console.log(cat instanceof Cat); // false
```

不限制调用方式，不管是new 子类()还是子类(),返回的对象具有相同的效果
缺点：

实例是父类的实例，不是子类的实例
不支持多继承

4. 拷贝继承

```
function Cat(name){
  var animal = new Animal();
  for(var p in animal){
    Cat.prototype[p] = animal[p];
  }
  Cat.prototype.name = name || 'Tom';
}

// Test Code
var cat = new Cat();
console.log(cat.name);
console.log(cat.sleep());
console.log(cat instanceof Animal); // false
console.log(cat instanceof Cat); // true
```

特点：

支持多继承
缺点：

效率较低，内存占用高（因为要拷贝父类的属性）
无法获取父类不可枚举的方法（不可枚举方法，不能使用for in 访问到）


5. 组合继承

核心：通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用


```
function Cat(name){
  Animal.call(this);
  this.name = name || 'Tom';
}
Cat.prototype = new Animal();
Cat.prototype.constructor = Cat; //constructor的定义是要指向原型属性对应的构造函数

// Test Code
var cat = new Cat();
console.log(cat.name);
console.log(cat.sleep());
console.log(cat instanceof Animal); // true
console.log(cat instanceof Cat); // true
```

特点：

弥补了方式2的缺陷，可以继承实例属性/方法，也可以继承原型属性/方法
既是子类的实例，也是父类的实例
不存在引用属性共享问题
可传参
函数可复用
缺点：

调用了两次父类构造函数，生成了两份实例（子类实例将子类原型上的那份屏蔽了）

5. (1)组合式继承优化
直接把父类的原型对象赋给子类的原型对象


```
function Parent3() {
    this.name = "parent3";
    this.colors = ["red", "blue", "yellow"];
}
Parent3.prototype.sex = "男";
Parent3.prototype.say = function () { console.log("Oh, My God！") }
function Child3() { 
    Parent3.call(this); this.type = "child3";
 }
Child3.prototype = Parent3.prototype; 
var s1 = new Child3();
var s2 = new Child3();
console.log(s1, s2);

console.log(s1 instanceof Child3); // true
console.log(s1 instanceof Parent3); // true

console.log(s1.constructor.name); // Parent3

```
5. (2)组合式继承优化    (寄生组合继承)

```
function Parent4(){ 
    this.name = "parent4"; 
    this.colors = ["red","blue","yellow"]; 
} 
Parent4.prototype.sex = "男"; 
Parent4.prototype.say = function(){console.log("Oh, My God！")}
function Child4(){
     Parent4.call(this); this.type = "child4"; 
     } 
Child4.prototype = Object.create(Parent4.prototype);
Child4.prototype.constructor = Child4;

```

var p = {name: "p"};
var obj = Object.create(p) 
// Object.create({ name: "p" })


6. 寄生组合继承

核心：通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次实例方法/属性，避免的组合继承的缺点

```
function Cat(name){
  Animal.call(this);
  this.name = name || 'Tom';
}
(function(){
  // 创建一个没有实例方法的类
  var Super = function(){};
  Super.prototype = Animal.prototype;
  //将实例作为子类的原型
  Cat.prototype = new Super();
})();

// Test Code
var cat = new Cat();
console.log(cat.name);
console.log(cat.sleep());
console.log(cat instanceof Animal); // true
console.log(cat instanceof Cat); //true
Cat.prototype.constructor = Cat; // 需要修复下构造函数
```
### es6 继承

Class 可以通过extends关键字实现继承

```
class Parent { } 
class Child1 extends Parent {
    constructor(x, y, colors) {
        super(x, y); // 调用父类的constructor(x, y) 
        this.colors = colors;
    }
    toString() {
        return this.colors + ' ' + super.toString(); // 调用父类的toString() 
    }
}

```
### JS模块的封装方法，比如怎样实现私有变量，不能直接赋值，只能通过公有方法

```
function P(pwd){
    var password = pwd;
    function getPasswd(){
        return password;
    }
    this.pwdService = function(){
        return getPasswd();
    }
}
P.prototype.checkPwd = function(pwd){
     return this.pwdService()===pwd; 
}
var p = new P('1111');
console.log(p.checkPwd('1111'));    // true
console.log(p.password)   //undefined
console.log(p.getPassword())    //Type error  p.getPassword() is not a function
console.log(p.getPassword)  //undefined

```
### 闭包理解和优缺点

内部函数访问外部函数的变量。

好处：可以模拟oo的一些特性（设计私有的方法和变量。进行一些更加高级的js应用）。可以防止模块间的污染。缓存。 
匿名自执行函数，匿名自执行函数可以减小内存消耗。

坏处：占有内存不能得到释放。

闭包比一般的函数需要更多的内存消耗。尤其在IE浏览器中需要关注。由于IE使用非原生javascript对象实现DOM对象，因此闭包会导致内存泄露问题，例如：

```

function A(){  
      var a=document.createElement("div")，// 
            msg="Hello";  
       a.onclick=function(){  
          alert(msg);  
          }  
   }  
 A();
以上的闭包会在IE下导致内存泄露，假设A()执行时创建的作用域对象ScopeA，ScopeA引用了DOM对象a,DOM对象a 
引用了function(aleert(msg))，函数function(alert(msg))引用了ScopeA，这是一个循环引用，在IE会导致内存泄露。

```